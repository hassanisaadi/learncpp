# C++ Nanodegree Program (Udacity)
In this file, I just summarized code snippets from this program. It's for personal reference.

## [1. Welcome](./01_welcome/)
## [2. Foundations](./02_foundations/README.MD#2-foundations)
### [2.1. Introduction to the C++ Language](./02_foundations/README.MD#1-introduction-to-the-c-language)
### [2.2. A* Search](./02_foundations/README.MD#2-a-search)
#### [2.2.1. Passing by Reference](./02_foundations/README.MD#21-passing-by-reference)
#### [2.2.2. `const` vs. `constexpr`](./02_foundations/README.MD#22-const-vs-constexpr)
#### [2.2.3. Arrays vs. Vectors](./02_foundations/README.MD#23-arrays-vs-vectors)
#### [2.2.4. A* Search full Program](./02_foundations/README.MD#24-a-search-full-program)
### [2.3. Wrting Multifile Programs](./02_foundations/README.MD#3-writing-multifile-programs)
#### [2.3.1. Include Guard](./02_foundations/README.MD#31-include-guard)
#### [2.3.2. Multifile Program Example](./02_foundations/README.MD#32-multifile-program-example)
#### [2.3.3. References](./02_foundations/README.MD#33-references)
#### [2.3.4. Pointers](./02_foundations/README.MD#34-pointers)
##### [2.3.4.1. Accessing a Memory Address](./02_foundations/README.MD#341-accessing-a-memory-address)
##### [2.3.4.2. Storing a Memory Address](./02_foundations/README.MD#342-storing-a-memory-address)
##### [2.3.4.3. Dereferencing Operator - Getting an Object Back from a Pointer Address](./02_foundations/README.MD#343-dereferencing-operator---getting-an-object-back-from-a-pointer-address)
##### [2.3.4.4. Passing Pointers to a Function](./02_foundations/README.MD#344-passing-pointers-to-a-function)
##### [2.3.4.5. Returning a Pointer from a Function](./02_foundations/README.MD#345-returning-a-pointer-from-a-function)
#### [2.3.5. References vs Pointers](./02_foundations/README.MD#35-references-vs-pointers)
#### [2.3.6. Maps (`uordered_map`)](./02_foundations/README.MD#36-maps-unordered_map)
#### [2.3.7. `->` Operator](./02_foundations/README.MD#37---operator)
#### [2.3.8. A little OOP](./02_foundations/README.MD#38-a-little-oop)
#### [2.3.9. `this` Pointer](./02_foundations/README.MD#39-this-pointer)

## [3. Object-oriented Programming](./03_oop/README.md#3-object-oriented-programming)
### [3.1. `struct` vs `class`](./03_oop/README.md#31-struct-vs-class)
### [3.2. Classes](./03_oop/README.md#32-classes)
### [3.3. Scope Resolution](./03_oop/README.md#33-scope-resolution)
### [3.4. Initializer List](./03_oop/README.md#34-initializer-list)
#### [3.4.1. Why initialization list?](./03_oop/README.md#341-why-initialization-list)
### [3.5. Accessor Functions](./03_oop/README.md#35-accessor-functions)
#### [3.5.1. `const` Accessor Function](./03_oop/README.md#351-const-accessor-function)
### [3.6. Mutator Functions](./03_oop/README.md#36-mutator-functions)
### [3.7. Abstraction](./03_oop/README.md#37-abstraction)
### [3.8. Static Members](./03_oop/README.md#38-static-members)
#### [3.8.1. Implementation](./03_oop/README.md#381-implementation)
#### [3.8.2. Static Method](./03_oop/README.md#382-static-method)
### [3.9. Access Modifiers in C](./03_oop/README.md#39-access-modifiers-in-c)
### [3.10. Inheritence](./03_oop/README.md#310-inheritence)
#### [3.10.1. Inherited access specifiers](./03_oop/README.md#3101-inherited-access-specifiers)
### [3.11. Composition](./03_oop/README.md#311-composition)
### [3.12. Friends](./03_oop/README.md#312-friends)
### [3.13. Polymorphism](./03_oop/README.md#313-polymorphism)
#### [3.13.1. Overloading](./03_oop/README.md#3131-overloading)
##### [3.13.1.1. Operator Overloading](./03_oop/README.md#31311-operator-overloading)
### [3.14. Virtual Functions](./03_oop/README.md#314-virtual-functions)
### [3.15. Polymorphism - Overriding](./03_oop/README.md#315-polymorphism-overriding)
### [3.16. Function Hiding](./03_oop/README.md#316-function-hiding)
### [3.17. `override`](./03_oop/README.md#317-override)
### [3.18. Multiple Inheritence](./03_oop/README.md#318-multiple-inheritence)
#### [3.18.1. The Diamond Problem](./03_oop/README.md#3181-the-diamond-problem)
### [3.19. Generic Programming using `template`](./03_oop/README.md#319-generic-programming-using-template)

## [4. Memory Management](./04_mem/README.MD#4-memory-management)
### [4.1. Debugging (`gdb`)](./04_mem/README.MD#41-debugging-gdb)
### [4.2. Types of Computer Memory](./04_mem/README.MD#42-types-of-computer-memory)
### [4.3. Cache Memory](./04_mem/README.MD#43-cache-memory)
#### [4.3.1. Temporal and Spatial Locality](./04_mem/README.MD#431-temporal-and-spatial-locality)
### [4.4. Vritual Memory](./04_mem/README.MD#44-virtual-memory)
#### [4.4.1. Problems with Physical Memory](./04_mem/README.MD#441-problems-with-physical-mermory)
### [4.5. The process memory model](./04_mem/README.MD#45-the-process-memory-model)
### [4.6. Memory Allociation in C++](./04_mem/README.MD#46-memory-allocation-in-c)
### [4.7. Automatic memory allocation (The Stack)](./04_mem/README.MD#47-automatic-memory-allocation-the-stack)
### [4.8. Call by reference vs. Call by value](./04_mem/README.MD#48-call-by-reference-vs-call-by-value)
#### [4.8.1. Pointers vs. References](./04_mem/README.MD#481-pointers-vs-references)
#### [4.8.2. Three ways to pass a value to a function](./04_mem/README.MD#482-three-ways-to-pass-a-value-to-a-function)
### [4.9. Heap Memory](./04_mem/README.MD#49-heap-memory)
#### [4.9.1. Memory Fragmentation](./04_mem/README.MD#491-memory-fragmentation)
### [4.10. Using `malloc` and `free`](./04_mem/README.MD#410-using-malloc-and-free)
#### [4.10.1. Dangling Pointers](./04_mem/README.MD#4101-dangling-pointer)
### [4.11. Using `new` and `delete`](./04_mem/README.MD#411-using-new-and-delete)
#### [4.11.1. Optimizing performance with placement `new`](./04_mem/README.MD#4111-optimizing-performance-with-palcement-new)
#### [4.11.2. Overloading `new` and `delete`](./04_mem/README.MD#4112-overloading-new-and-delete)
#### [4.11.3. Pverloading `new[]` and `delete[]`](./04_mem/README.MD#4113-overloading-new-and-delete)
#### [4.11.4. Reasons for overloading `new` and `delete`](./04_mem/README.MD#4114-reasons-for-overloading-new-and-delete)
### [4.12. Overloading of memory management problems](./04_mem/README.MD#412-overview-of-memory-management-problems)
### [4.13. Copy Semantics](./04_mem/README.MD#413-copy-semantics)
#### [4.13.1. No Copying Policy](./04_mem/README.MD#4131-no-copying-policy)
#### [4.13.2. Exclusive Ownership Policy](./04_mem/README.MD#4132-exclusive-ownership-policy)
#### [4.13.3. Deep Copying Policy](./04_mem/README.MD#4133-deep-copying-policy)
#### [4.13.4. Shared Ownership Policy](./04_mem/README.MD#4134-shared-ownership-policy)
### [4.14. Lvalues and Rvalues](./04_mem/README.MD#414-lvalues-and-rvalues)
#### [4.14.1. lvalue references](./04_mem/README.MD#4141-lvalue-references)
#### [4.14.2. rvalue references](./04_mem/README.MD#4142-rvalue-references)
### [4.15. Move Semantics](./04_mem/README.MD#415-move-semantics)
#### [4.15.1. rvalue references and `std::move`](./04_mem/README.MD#4151-rvalue-references-and-stdmove)
#### [4.15.2. The Rule of Three](./04_mem/README.MD#4152-rule-of-three)
#### [4.15.3. Move Constructor](./04_mem/README.MD#4153-the-move-constructor)
#### [4.15.4. The Rule of Five](./04_mem/README.MD#4154-the-rule-of-five)
#### [4.15.5. When are move semantics used?](./04_mem/README.MD#4155-when-are-move-semantics-used)
#### [4.15.6. Moving lvalues](./04_mem/README.MD#4156-moving-lvalues)
### [4.16. Smart Pointers](./04_mem/README.MD#416-smart-pointers)
#### [4.16.1. Error prone memory management with `new` and `delete`](./04_mem/README.MD#4161-error-prone-memory-management-with-new-and-delete)
#### [4.16.2. Resource Acquisition in Initialization - RAII](./04_mem/README.MD#4162-resource-acquisition-in-initialization---raii)
#### [4.16.3. Smart pointer overview](./04_mem/README.MD#4163-smart-pointer-overview)
#### [4.16.4. The Unique Pointer](./04_mem/README.MD#4164-the-unique-pointer)
#### [4.16.5. The Shared Pointer](./04_mem/README.MD#4165-the-shared-pointer)
#### [4.16.6. The Weak Pointer](./04_mem/README.MD#4166-the-weak-pointer)
#### [4.16.7. Converting between Smart Pointers](./04_mem/README.MD#4167-converting-between-smart-pointers)
### [4.17. Transferring Ownership](./04_mem/README.MD#417-transferring-ownership)
#### [4.17.1. Passing smart pointers to functions](./04_mem/README.MD#4171-passing-smart-pointers-to-functions)
#### [4.17.2. Returning smart pointers from functions](./04_mem/README.MD#4172-returning-smart-pointers-from-functions)
### [4.18. Best Practices for passing smart pointers](./04_mem/README.MD#418-best-practices-for-passing-smart-pointers)
#### [4.18.1. The preferred way](./04_mem/README.MD#4181-the-preferred-way)
#### [4.18.2. The Object Sink](./04_mem/README.MD#4182-the-object-sink)
#### [4.18.3. In and Out Again 1](./04_mem/README.MD#4183-in-and-out-again-1)
#### [4.18.4. Sharing Object Ownership](./04_mem/README.MD#4184-sharing-object-ownership)
#### [4.18.5. In and Out Again 2](./04_mem/README.MD#4185-in-and-out-again-2)

## [5. Concurrency]()

# Disclaimer
All the materials, images, links are from the Udacity C++ Nanodegree program. It's just a personal use archive for myself (or someone interested).
