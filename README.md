# C++ Nanodegree Program (Udacity)
In this file, I just summarized code snippets from this program. It's for personal reference.

## [1. Welcome](./01_welcome/)
## [2. Foundations](./02_foundations/README.MD#2-foundations)
### [2.1. Introduction to the C++ Language](./02_foundations/README.MD#1-introduction-to-the-c-language)
### [2.2. A* Search](./02_foundations/README.MD#2-a-search)
#### [2.2.1. Passing by Reference](./02_foundations/README.MD#21-passing-by-reference)
#### [2.2.2. `const` vs. `constexpr`](./02_foundations/README.MD#22-const-vs-constexpr)
#### [2.2.3. Arrays vs. Vectors](./02_foundations/README.MD#23-arrays-vs-vectors)
#### [2.2.4. A* Search full Program](./02_foundations/README.MD#24-a-search-full-program)
### [2.3. Wrting Multifile Programs](./02_foundations/README.MD#3-writing-multifile-programs)
#### [2.3.1. Include Guard](./02_foundations/README.MD#31-include-guard)
#### [2.3.2. Multifile Program Example](./02_foundations/README.MD#32-multifile-program-example)
#### [2.3.3. References](./02_foundations/README.MD#33-references)
#### [2.3.4. Pointers](./02_foundations/README.MD#34-pointers)
##### [2.3.4.1. Accessing a Memory Address](./02_foundations/README.MD#341-accessing-a-memory-address)
##### [2.3.4.2. Storing a Memory Address](./02_foundations/README.MD#342-storing-a-memory-address)
##### [2.3.4.3. Dereferencing Operator - Getting an Object Back from a Pointer Address](./02_foundations/README.MD#343-dereferencing-operator---getting-an-object-back-from-a-pointer-address)
##### [2.3.4.4. Passing Pointers to a Function](./02_foundations/README.MD#344-passing-pointers-to-a-function)
##### [2.3.4.5. Returning a Pointer from a Function](./02_foundations/README.MD#345-returning-a-pointer-from-a-function)
#### [2.3.5. References vs Pointers](./02_foundations/README.MD#35-references-vs-pointers)
#### [2.3.6. Maps (`uordered_map`)](./02_foundations/README.MD#36-maps-unordered_map)
#### [2.3.7. `->` Operator](./02_foundations/README.MD#37---operator)
#### [2.3.8. A little OOP](./02_foundations/README.MD#38-a-little-oop)
#### [2.3.9. `this` Pointer](./02_foundations/README.MD#39-this-pointer)

## [3. Object-oriented Programming](./03_oop/README.md#3-object-oriented-programming)
### [3.1. `struct` vs `class`](./03_oop/README.md#31-struct-vs-class)
### [3.2. Classes](./03_oop/README.md#32-classes)
### [3.3. Scope Resolution](./03_oop/README.md#33-scope-resolution)
### [3.4. Initializer List](./03_oop/README.md#34-initializer-list)
#### [3.4.1. Why initialization list?](./03_oop/README.md#341-why-initialization-list)
### [3.5. Accessor Functions](./03_oop/README.md#35-accessor-functions)
#### [3.5.1. `const` Accessor Function](./03_oop/README.md#351-const-accessor-function)
### [3.6. Mutator Functions](./03_oop/README.md#36-mutator-functions)
### [3.7. Abstraction](./03_oop/README.md#37-abstraction)
### [3.8. Static Members](./03_oop/README.md#38-static-members)
#### [3.8.1. Implementation](./03_oop/README.md#381-implementation)
#### [3.8.2. Static Method](./03_oop/README.md#382-static-method)
### [3.9. Access Modifiers in C](./03_oop/README.md#39-access-modifiers-in-c)
### [3.10. Inheritence](./03_oop/README.md#310-inheritence)
#### [3.10.1. Inherited access specifiers](./03_oop/README.md#3101-inherited-access-specifiers)
### [3.11. Composition](./03_oop/README.md#311-composition)
### [3.12. Friends](./03_oop/README.md#312-friends)
### [3.13. Polymorphism](./03_oop/README.md#313-polymorphism)
#### [3.13.1. Overloading](./03_oop/README.md#3131-overloading)
##### [3.13.1.1. Operator Overloading](./03_oop/README.md#31311-operator-overloading)
### [3.14. Virtual Functions](./03_oop/README.md#314-virtual-functions)
### [3.15. Polymorphism - Overriding](./03_oop/README.md#315-polymorphism-overriding)
### [3.16. Function Hiding](./03_oop/README.md#316-function-hiding)
### [3.17. `override`](./03_oop/README.md#317-override)
### [3.18. Multiple Inheritence](./03_oop/README.md#318-multiple-inheritence)
#### [3.18.1. The Diamond Problem](./03_oop/README.md#3181-the-diamond-problem)
### [3.19. Generic Programming using `template`](./03_oop/README.md#319-generic-programming-using-template)

## [4. Memory Management](./04_mem/README.MD#4-memory-management)
### [4.1. Debugging (`gdb`)](./04_mem/README.MD#41-debugging-gdb)
### [4.2. Types of Computer Memory](./04_mem/README.MD#42-types-of-computer-memory)
### [4.3. Cache Memory](./04_mem/README.MD#43-cache-memory)
#### [4.3.1. Temporal and Spatial Locality](./04_mem/README.MD#431-temporal-and-spatial-locality)
### [4.4. Vritual Memory](./04_mem/README.MD#44-virtual-memory)
#### [4.4.1. Problems with Physical Memory](./04_mem/README.MD#441-problems-with-physical-mermory)
### [4.5. The process memory model](./04_mem/README.MD#45-the-process-memory-model)
### [4.6. Memory Allociation in C++](./04_mem/README.MD#46-memory-allocation-in-c)
### [4.7. Automatic memory allocation (The Stack)](./04_mem/README.MD#47-automatic-memory-allocation-the-stack)
### [4.8. Call by reference vs. Call by value](./04_mem/README.MD#48-call-by-reference-vs-call-by-value)
#### [4.8.1. Pointers vs. References](./04_mem/README.MD#481-pointers-vs-references)
#### [4.8.2. Three ways to pass a value to a function](./04_mem/README.MD#482-three-ways-to-pass-a-value-to-a-function)
### [4.9. Heap Memory](./04_mem/README.MD#49-heap-memory)
#### [4.9.1. Memory Fragmentation](./04_mem/README.MD#491-memory-fragmentation)
### [4.10. Using `malloc` and `free`](./04_mem/README.MD#410-using-malloc-and-free)
#### [4.10.1. Dangling Pointers](./04_mem/README.MD#4101-dangling-pointer)
### [4.11. Using `new` and `delete`](./04_mem/README.MD#411-using-new-and-delete)
#### [4.11.1. Optimizing performance with placement `new`](./04_mem/README.MD#4111-optimizing-performance-with-palcement-new)
#### [4.11.2. Overloading `new` and `delete`](./04_mem/README.MD#4112-overloading-new-and-delete)
#### [4.11.3. Pverloading `new[]` and `delete[]`](./04_mem/README.MD#4113-overloading-new-and-delete)
#### [4.11.4. Reasons for overloading `new` and `delete`](./04_mem/README.MD#4114-reasons-for-overloading-new-and-delete)
### [4.12. Overloading of memory management problems](./04_mem/README.MD#412-overview-of-memory-management-problems)
### [4.13. Copy Semantics](./04_mem/README.MD#413-copy-semantics)
#### [4.13.1. No Copying Policy](./04_mem/README.MD#4131-no-copying-policy)
#### [4.13.2. Exclusive Ownership Policy](./04_mem/README.MD#4132-exclusive-ownership-policy)
#### [4.13.3. Deep Copying Policy](./04_mem/README.MD#4133-deep-copying-policy)
#### [4.13.4. Shared Ownership Policy](./04_mem/README.MD#4134-shared-ownership-policy)
### [4.14. Lvalues and Rvalues](./04_mem/README.MD#414-lvalues-and-rvalues)
#### [4.14.1. lvalue references](./04_mem/README.MD#4141-lvalue-references)
#### [4.14.2. rvalue references](./04_mem/README.MD#4142-rvalue-references)
### [4.15. Move Semantics](./04_mem/README.MD#415-move-semantics)
#### [4.15.1. rvalue references and `std::move`](./04_mem/README.MD#4151-rvalue-references-and-stdmove)
#### [4.15.2. The Rule of Three](./04_mem/README.MD#4152-rule-of-three)
#### [4.15.3. Move Constructor](./04_mem/README.MD#4153-the-move-constructor)
#### [4.15.4. The Rule of Five](./04_mem/README.MD#4154-the-rule-of-five)
#### [4.15.5. When are move semantics used?](./04_mem/README.MD#4155-when-are-move-semantics-used)
#### [4.15.6. Moving lvalues](./04_mem/README.MD#4156-moving-lvalues)
### [4.16. Smart Pointers](./04_mem/README.MD#416-smart-pointers)
#### [4.16.1. Error prone memory management with `new` and `delete`](./04_mem/README.MD#4161-error-prone-memory-management-with-new-and-delete)
#### [4.16.2. Resource Acquisition in Initialization - RAII](./04_mem/README.MD#4162-resource-acquisition-in-initialization---raii)
#### [4.16.3. Smart pointer overview](./04_mem/README.MD#4163-smart-pointer-overview)
#### [4.16.4. The Unique Pointer](./04_mem/README.MD#4164-the-unique-pointer)
#### [4.16.5. The Shared Pointer](./04_mem/README.MD#4165-the-shared-pointer)
#### [4.16.6. The Weak Pointer](./04_mem/README.MD#4166-the-weak-pointer)
#### [4.16.7. Converting between Smart Pointers](./04_mem/README.MD#4167-converting-between-smart-pointers)
### [4.17. Transferring Ownership](./04_mem/README.MD#417-transferring-ownership)
#### [4.17.1. Passing smart pointers to functions](./04_mem/README.MD#4171-passing-smart-pointers-to-functions)
#### [4.17.2. Returning smart pointers from functions](./04_mem/README.MD#4172-returning-smart-pointers-from-functions)
### [4.18. Best Practices for passing smart pointers](./04_mem/README.MD#418-best-practices-for-passing-smart-pointers)
#### [4.18.1. The preferred way](./04_mem/README.MD#4181-the-preferred-way)
#### [4.18.2. The Object Sink](./04_mem/README.MD#4182-the-object-sink)
#### [4.18.3. In and Out Again 1](./04_mem/README.MD#4183-in-and-out-again-1)
#### [4.18.4. Sharing Object Ownership](./04_mem/README.MD#4184-sharing-object-ownership)
#### [4.18.5. In and Out Again 2](./04_mem/README.MD#4185-in-and-out-again-2)

## [5. Concurrency](./05_concurr/README.MD#5-concurrency)
### [5.1. Processes and Threads](./05_concurr/README.MD#51-processes-and-threads)
### [5.2. Running a Single Thread](./05_concurr/README.MD#52-running-a-single-thread)
#### [5.2.1. Starting a Second Thread](./05_concurr/README.MD#521-starting-a-second-thread)
#### [5.2.2. Randomness of events](./05_concurr/README.MD#522-randomness-of-events)
#### [5.2.3. Detach](./05_concurr/README.MD#523-detach)
### [5.3. Starting a Thread with a function object](./05_concurr/README.MD#53-starting-a-thread-with-a-function-object)
#### [5.3.1. Functions and Callable Objects](./05_concurr/README.MD#531-functions-and-callable-objects)
#### [5.3.2. Threads and Function Objects](./05_concurr/README.MD#532-threads-and-function-objects)
#### [5.3.3. Lambdas](./05_concurr/README.MD#533-lambdas)
#### [5.3.4. Starting Threads with Lambdas](./05_concurr/README.MD#534-starting-threads-with-lambdas)
### [5.4. Starting a Thread with Variadic Templates and Member Functions](./05_concurr/README.MD#54-starting-a-thread-with-variadic-templates-and-member-functions)
#### [5.4.1. Passing Arguments using a Variadic Templates](./05_concurr/README.MD#541-passing-arguments-using-a-variadic-templates)
#### [5.4.2. Starting Threads with Member Functions](./05_concurr/README.MD#542-starting-threads-with-member-functions)
### [5.5. Running Multiple Threads](./05_concurr/README.MD#55-running-multiple-threads)
#### [5.5.1. Fork-Join Parallelism](./05_concurr/README.MD#551-fork-join-parallelism)
### [5.6. Passing Data Between Threads](./05_concurr/README.MD#56-passing-data-between-threads)
#### [5.6.1. Promises and Futures](./05_concurr/README.MD#561-promises-and-futures)
##### [5.6.1.1. `get()` vs. `wait()`](./05_concurr/README.MD#5611-get-vs-wait)
##### [5.6.1.2. Passing Exception](./05_concurr/README.MD#5612-passing-exception)
#### [5.6.2. Threads vs. Tasks](./05_concurr/README.MD#562-threads-vs-tasks)
##### [5.6.2.1. Starting Threads with `async`](./05_concurr/README.MD#5621-starting-threads-with-async)
##### [5.6.2.2. Task based Concurrency](./05_concurr/README.MD#5622-task-based-concurrency)
#### [5.6.3. Avoiding data races](./05_concurr/README.MD#563-avoiding-data-races)
##### [5.6.3.1. Understanding data races](./05_concurr/README.MD#5631-understanding-data-races)
##### [5.6.3.2. Passing data to a Thread by Value](./05_concurr/README.MD#5632-passing-data-to-a-thread-by-value)
##### [5.6.3.3. Overwriting the Copy Constructor](./05_concurr/README.MD#5633-overwriting-the-copy-constructor)
##### [5.6.3.4. Passing data Using Move Semantics](./05_concurr/README.MD#5634-passing-data-using-move-semantics)
##### [5.6.3.5. Move Semantics and Uniqueness](./05_concurr/README.MD#5635-move-semantics-and-uniqueness)
### [5.7. Mutexes and Locks](./05_concurr/README.MD#57-mutexes-and-locks)
#### [5.7.1. Using a Mutex to Protect Shared Data](./05_concurr/README.MD#571-using-a-mutex-to-protect-shared-data)
##### [5.7.1.1. The Mutex Entity](./05_concurr/README.MD#5711-the-mutex-entity)
##### [5.7.1.2. Using Mutex to Protect Data](./05_concurr/README.MD#5712-using-mutex-to-protect-data)
##### [5.7.1.3. Using `timed_mutex`](./05_concurr/README.MD#5713-using-timed_mutex)
##### [5.7.1.4. Deadlock](./05_concurr/README.MD#5714-deadlock)
#### [5.7.2. Using Locks to Avoid Deadlocks](./05_concurr/README.MD#572-using-locks-to-avoid-deadlocks)
##### [5.7.2.1. Lock Guard](./05_concurr/README.MD#5721-lock-guard)
##### [5.7.2.2. `unique_lock()`](./05_concurr/README.MD#5722-unique-lock)
### [5.8. Condition Variables and Message Queues](./05_concurr/README.MD#58-condition-variables-and-message-queues)
#### [5.8.1. The Monitor Object Pattern](./05_concurr/README.MD#581-the-monitor-object-pattern)
#### [5.8.2. Building a Concurrent Message Queue](./05_concurr/README.MD#582-building-a-concurrent-message-queue)
##### [5.8.2.1. Building a Generic Message Queue](./05_concurr/README.MD#5821-building-a-generic-message-queue)

